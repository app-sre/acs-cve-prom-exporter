package acs

import (
	"context"
	"crypto/tls"
	"errors"
	"fmt"
	"log"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/Khan/genqlient/graphql"
	"github.com/app-sre/acs-cve-prom-exporter/internal/collector"
	"github.com/app-sre/acs-cve-prom-exporter/internal/gql"
	"github.com/prometheus/client_golang/prometheus"
)

type bearerTokenTransport struct {
	Base  http.RoundTripper
	Token string
}

func (t *bearerTokenTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	clonedReq := req.Clone(req.Context())
	clonedReq.Header.Set("Authorization", fmt.Sprintf("Bearer %s", t.Token))
	return t.Base.RoundTrip(clonedReq)
}

type Client struct {
	gqlClient graphql.Client
}

func NewMetricsGenClient(endpoint string, token string) *Client {
	transport := &bearerTokenTransport{
		Base: &http.Transport{
			TLSClientConfig: &tls.Config{
				MinVersion: tls.VersionTLS13,
			},
		},
		Token: token,
	}

	httpClient := http.Client{
		Transport: transport,
		Timeout:   time.Second * 50,
	}

	gqlClient := graphql.NewClient(fmt.Sprintf("%s/api/graphql", endpoint), &httpClient)

	return &Client{
		gqlClient: gqlClient,
	}
}

func (acs *Client) GetClusters() (*gql.GetClustersResponse, error) {
	ctx := context.Background()

	resp, err := gql.GetClusters(
		ctx,
		acs.gqlClient,
	)
	return resp, err
}

func (acs *Client) GetNamespaces(clusterId string) (*gql.GetNamespacesByClusterIDResponse, error) {
	ctx := context.Background()

	resp, err := gql.GetNamespacesByClusterID(
		ctx,
		acs.gqlClient,
		clusterId,
	)
	return resp, err
}

func (acs *Client) GetNamespaceVulnerabilities(namespaceId string) (*gql.GetImageVulnerabilitiesByNamespaceIDResponse, error) {
	ctx := context.Background()

	resp, err := gql.GetImageVulnerabilitiesByNamespaceID(
		ctx,
		acs.gqlClient,
		namespaceId,
	)
	return resp, err
}

func ConvertLabelsToString(labels prometheus.Labels) string {
	if len(labels) == 0 {
		return ""
	}

	var labelPairs []string
	for key, value := range labels {
		labelPairs = append(labelPairs, fmt.Sprintf("%s=%s", key, value))
	}

	sort.Strings(labelPairs)

	return strings.Join(labelPairs, ",")
}

func ProcessVulnerabilities(
	manager *collector.CollectorManager,
	metricsGenClient *Client,
	cluster gql.GetClustersClustersCluster,
	namespace gql.GetNamespacesByClusterIDClusterNamespacesNamespace,
) error {

	log.Printf("Getting Vulnerabilities for cluster %s namespace %s", cluster.Name, namespace.Metadata.Name)
	vulnerabilities, err := metricsGenClient.GetNamespaceVulnerabilities(namespace.Metadata.Id)
	if err != nil {
		return err
	}
	for _, vulnerability := range vulnerabilities.Namespace.ImageVulnerabilities {
		if !vulnerability.IsFixable {
			continue
		}
		if vulnerability.Severity != "CRITICAL_VULNERABILITY_SEVERITY" && vulnerability.Severity != "IMPORTANT_VULNERABILITY_SEVERITY" {
			continue
		}

		if vulnerability.DeploymentCount == 0 {
			continue
		}

		log.Printf("Getting Images for vulnerability %s", vulnerability.Cve)
		for _, image := range vulnerability.Images {
			labels := prometheus.Labels{
				"cluster":         cluster.Name,
				"cve":             vulnerability.Cve,
				"severity":        vulnerability.Severity,
				"isFixable":       strconv.FormatBool(vulnerability.IsFixable),
				"deploymentCount": strconv.FormatInt(int64(vulnerability.DeploymentCount), 10),
				"namespace":       namespace.Metadata.Name,
				"imageRemote":     image.Name.Remote,
				"imageRegistry":   image.Name.Registry,
				"imageTag":        image.Name.Tag,
				"imageId":         image.Id,
				"operatingSystem": vulnerability.OperatingSystem,
			}

			index := ConvertLabelsToString(labels)
			log.Printf("Ensuring metric %s: %f", index, vulnerability.Cvss)
			manager.AddCollector(index, collector.NewMyCollector(labels, vulnerability.Cvss))
		}
	}
	return nil
}

func ProcessNamespaces(manager *collector.CollectorManager, metricsGenClient *Client) error {
	log.Printf("Getting Clusters")
	clusters, err := metricsGenClient.GetClusters()
	if err != nil {
		return fmt.Errorf("failed  getting Clusters from acs : %v", err)
	}
	var errs error
	for _, cluster := range clusters.Clusters {

		log.Printf("Getting Namespaces for cluster %s", cluster.Name)
		namespaces, err := metricsGenClient.GetNamespaces(cluster.Id)
		if err != nil {
			return fmt.Errorf("failed getting Namespaces from acs: %v", err)
		}
		for _, namespace := range namespaces.Cluster.Namespaces {
			// if ImageVulnerabilityCount is zero skip it
			if namespace.ImageVulnerabilityCount == 0 {
				continue
			}
			// Don't!!!
			// Don't even think about it!
			// Calling this in goroutines will DoS the ACS Central API.
			err = ProcessVulnerabilities(manager, metricsGenClient, cluster, namespace)
			if err != nil {
				errs = errors.Join(errs, fmt.Errorf("failed to process vulnerabilities: %v", err))
				continue
			}

		}
	}
	return errs
}

func Run(reg *prometheus.Registry, endpoint string, token string, exitSignal chan struct{}) {

	metricsGenClient := NewMetricsGenClient(
		endpoint,
		token,
	)

	oldManager := collector.NewCollectorManager(reg)

	for {
		newManager := collector.NewCollectorManager(reg)

		log.Println("Beginning collection from ACS...")
		err := ProcessNamespaces(newManager, metricsGenClient)
		if err != nil {
			log.Println("Error processing Namespaces::", err)
			exitSignal <- struct{}{}
			return
		}
		log.Println("Collection completed.")

		log.Println("Cleaning up old collectors...")
		for _, id := range oldManager.ListCollectors() {
			if !newManager.CollectorExists(id) {
				log.Printf("Removing metric %s", id)
				oldManager.RemoveCollectorReg(id)
			}
		}
		log.Println("Cleanup completed.")

		oldManager = newManager.Copy()
	}
}
