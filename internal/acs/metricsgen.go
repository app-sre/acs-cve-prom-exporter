package acs

import (
	"context"
	"crypto/tls"
	"fmt"
	"github.com/Khan/genqlient/graphql"
	"github.com/app-sre/acs-cve-prom-exporter/internal/collector"
	"github.com/app-sre/acs-cve-prom-exporter/internal/gql"
	"github.com/prometheus/client_golang/prometheus"
	"log"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"
)

type bearerTokenTransport struct {
	Base  http.RoundTripper
	Token string
}

func (t *bearerTokenTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	clonedReq := req.Clone(req.Context())
	clonedReq.Header.Set("Authorization", fmt.Sprintf("Bearer %s", t.Token))
	return t.Base.RoundTrip(clonedReq)
}

type Client struct {
	gqlClient graphql.Client
}

func NewMetricsGenClient(endpoint string, token string) (*Client, error) {
	transport := &bearerTokenTransport{
		Base: &http.Transport{
			TLSClientConfig: &tls.Config{
				MinVersion: tls.VersionTLS13,
			},
		},
		Token: token,
	}

	httpClient := http.Client{
		Transport: transport,
		Timeout:   time.Second * 50,
	}

	gqlClient := graphql.NewClient(fmt.Sprintf("%s/api/graphql", endpoint), &httpClient)

	return &Client{
		gqlClient: gqlClient,
	}, nil
}

func (acs *Client) GetClusters() (*gql.GetClustersResponse, error) {
	ctx := context.Background()

	resp, err := gql.GetClusters(
		ctx,
		acs.gqlClient,
	)
	if err != nil {
		log.Printf("Error fetching data: %v", err)
		return nil, err
	}
	return resp, nil
}

func (acs *Client) GetNamespaces(clusterId string) (*gql.GetNamespacesByClusterIDResponse, error) {
	ctx := context.Background()

	resp, err := gql.GetNamespacesByClusterID(
		ctx,
		acs.gqlClient,
		clusterId,
	)
	if err != nil {
		log.Printf("Error fetching data: %v", err)
		return nil, err
	}
	return resp, nil
}

func (acs *Client) GetNamespaceVulnerabilities(namespaceId string) (*gql.GetImageVulnerabilitiesByNamespaceIDResponse, error) {
	ctx := context.Background()

	resp, err := gql.GetImageVulnerabilitiesByNamespaceID(
		ctx,
		acs.gqlClient,
		namespaceId,
	)
	if err != nil {
		log.Printf("Error fetching data: %v", err)
		return nil, err
	}
	return resp, nil
}

func ConvertLabelsToString(labels prometheus.Labels) string {
	if len(labels) == 0 {
		return ""
	}

	var labelPairs []string
	for key, value := range labels {
		labelPairs = append(labelPairs, fmt.Sprintf("%s=%s", key, value))
	}

	sort.Strings(labelPairs)

	return strings.Join(labelPairs, ",")
}

func ProcessVulnerabilities(
	manager *collector.CollectorManager,
	metricsGenClient *Client,
	cluster gql.GetClustersClustersCluster,
	namespace gql.GetNamespacesByClusterIDClusterNamespacesNamespace,
) {

	log.Printf("Getting Vulnerabilities for cluster %s namespace %s", cluster.Name, namespace.Metadata.Name)
	vulnerabilities, _ := metricsGenClient.GetNamespaceVulnerabilities(namespace.Metadata.Id)
	for _, vulnerability := range vulnerabilities.Namespace.ImageVulnerabilities {
		if !vulnerability.IsFixable {
			continue
		}
		if vulnerability.Severity != "CRITICAL_VULNERABILITY_SEVERITY" && vulnerability.Severity != "IMPORTANT_VULNERABILITY_SEVERITY" {
			continue
		}

		if vulnerability.DeploymentCount == 0 {
			continue
		}

		log.Printf("Getting Images for vulnerability %s", vulnerability.Cve)
		for _, image := range vulnerability.Images {
			labels := prometheus.Labels{
				"cluster":         cluster.Name,
				"cve":             vulnerability.Cve,
				"severity":        vulnerability.Severity,
				"isFixable":       strconv.FormatBool(vulnerability.IsFixable),
				"deploymentCount": strconv.FormatInt(int64(vulnerability.DeploymentCount), 10),
				"namespace":       namespace.Metadata.Name,
				"imageRemote":     image.Name.Remote,
				"imageRegistry":   image.Name.Registry,
				"imageTag":        image.Name.Tag,
				"imageId":         image.Id,
				"operatingSystem": vulnerability.OperatingSystem,
			}

			index := ConvertLabelsToString(labels)
			log.Printf("Ensuring metric %s: %f", index, vulnerability.Cvss)
			manager.AddCollector(index, collector.NewMyCollector(labels, vulnerability.Cvss))
		}
	}
}

func ProcessNamespaces(manager *collector.CollectorManager, metricsGenClient *Client) {
	log.Printf("Getting Clusters")
	clusters, _ := metricsGenClient.GetClusters()
	for _, cluster := range clusters.Clusters {

		log.Printf("Getting Namespaces for cluster %s", cluster.Name)
		namespaces, _ := metricsGenClient.GetNamespaces(cluster.Id)
		for _, namespace := range namespaces.Cluster.Namespaces {

			// Don't!!!
			// Don't even think about it!
			// Calling this in goroutines will DoS the ACS Central API.
			ProcessVulnerabilities(manager, metricsGenClient, cluster, namespace)

		}
	}
}

func Run(reg *prometheus.Registry, endpoint string, token string) {

	metricsGenClient, _ := NewMetricsGenClient(
		endpoint,
		token,
	)

	oldManager := collector.NewCollectorManager(reg)

	for {
		newManager := collector.NewCollectorManager(reg)

		log.Println("Beginning collection from ACS...")
		ProcessNamespaces(newManager, metricsGenClient)
		log.Println("Collection completed.")

		log.Println("Cleaning up old collectors...")
		for _, id := range oldManager.ListCollectors() {
			if !newManager.CollectorExists(id) {
				log.Printf("Removing metric %s", id)
				oldManager.RemoveCollectorReg(id)
			}
		}
		log.Println("Cleanup completed.")

		oldManager = newManager.Copy()
	}
}
